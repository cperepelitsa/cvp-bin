#!/usr/bin/python2

# Assistant for the Thaumcraft 4 mod for Minecraft.

import os.path as path
import sys

primals = set(["Aer", "Aqua", "Ignis", "Ordo", "Perditio", "Terra"])

# create[C] = (A, B)
# A + B -> C
create = \
    { 'Alienis':      ('Tenebrae',     'Vacuos')
    , 'Arbor':        ('Herba',        'Aer')
    , 'Auram':        ('Aer',          'Praecantatio')
    , 'Bestia':       ('Victus',       'Motus')
    , 'Cognitio':     ('Spiritus',     'Ignis')
    , 'Corpus':       ('Bestia',       'Mortuus')
    , 'Exanimis':     ('Motus',        'Mortuus')
    , 'Fabrico':      ('Instrumentum', 'Humanus')
    , 'Fames':        ('Victus',       'Vacuos')
    , 'Gelum':        ('Perditio',     'Ignis')
    , 'Herba':        ('Victus',       'Terra')
    , 'Humanus':      ('Cognitio',     'Bestia')
    , 'Instrumentum': ('Humanus',      'Ordo')
    , 'Iter':         ('Terra',        'Motus')
    , 'Limus':        ('Victus',       'Aqua')
    , 'Lucrum':       ('Humanus',      'Fames')
    , 'Lux':          ('Aer',          'Ignis')
    , 'Machina':      ('Instrumentum', 'Motus')
    , 'Messis':       ('Humanus',      'Herba')
    , 'Metallum':     ('Vitreus',      'Terra')
    , 'Meto':         ('Instrumentum', 'Messis')
    , 'Mortuus':      ('Victus',       'Perditio')
    , 'Motus':        ('Aer',          'Ordo')
    , 'Pannus':       ('Instrumentum', 'Bestia')
    , 'Perfodio':     ('Humanus',      'Terra')
    , 'Permutatio':   ('Perditio',     'Ordo')
    , 'Potentia':     ('Ignis',        'Ordo')
    , 'Praecantatio': ('Potentia',     'Vacuos')
    , 'Sano':         ('Victus',       'Ordo')
    , 'Sensus':       ('Spiritus',     'Aer')
    , 'Spiritus':     ('Victus',       'Mortuus')
    , 'Telum':        ('Instrumentum', 'Ignis')
    , 'Tempestas':    ('Aer',          'Aqua')
    , 'Tenebrae':     ('Lux',          'Vacuos')
    , 'Tutamen':      ('Instrumentum', 'Terra')
    , 'Vacuos':       ('Aer',          'Perditio')
    , 'Venenum':      ('Perditio',     'Aqua')
    , 'Victus':       ('Terra',        'Aqua')
    , 'Vinculum':     ('Motus',        'Perditio')
    , 'Vitium':       ('Praecantatio', 'Perditio')
    , 'Vitreus':      ('Terra',        'Ordo')
    , 'Volatus':      ('Aer',          'Motus') }

allAspects = primals.union(create.keys())

def fatal(msg):
    print msg
    sys.exit(1)

def listAspects(args):
    if len(args) == 0:
        args = allAspects
    unrecognized = []
    for aspect in sorted(args):
        aspect = aspect.title()
        if aspect in primals:
            print "%s (primal)" % aspect
        elif aspect not in allAspects:
            unrecognized.append(aspect)
        else:
            a, b = create[aspect]
            print "%s = %s + %s" % (aspect, a, b)
    if len(unrecognized) > 0:
        print "\nnot recognized:"
        for aspect in unrecognized:
            print '    "%s"' % aspect

def fullBuildOrder():
    have = primals.copy()
    need = allAspects - primals
    order = []
    while len(need) > 0:
        got = set()
        for aspect in need:
            if aspect not in create:
                fatal("no way to make %s" % aspect)
            (a, b) = create[aspect]
            if a in have and b in have:
                order.append("%s + %s -> %s" % (a, b, aspect))
                got.add(aspect)
        if len(got) == 0:
            fatal("can't proceed\nhave: %s\nneed: %s" % (repr(have), repr(need)))
        have.update(got)
        need.difference_update(got)
    return order

def makeAspect(args):
    if len(args) == 0:
        for step in fullBuildOrder():
            print step
    else:
        unrecognized = []
        for aspect in args:
            aspect = aspect.title()
            if aspect in primals:
                print "%s (primal)" % aspect
            elif aspect not in create:
                unrecognized.append(aspect)
            else:
                a, b = create[aspect]
                print "%s = %s + %s" % (aspect, a, b)
        if len(unrecognized) > 0:
            print
            print "not recognized:"
            for aspect in unrecognized:
                print '    "%s"' % aspect

# tier[A] = complexity of aspect
# primals are tier 0
# direct combinations of 2 primals are tier 1
# otherwise, tier is 1 + the max of tiers of component aspects
tier = {}
def buildTier():
    for aspect in primals:
        tier[aspect] = 0
    need = allAspects - primals

    # probably a more elegant way to do this,
    # but n=48 is so small, so who gives a fuck
    while len(need) > 0:
        remove = set()
        for aspect in need:
            a, b = create[aspect]
            if a not in tier or b not in tier:
                continue
            tier[aspect] = max(tier[a], tier[b]) + 1
            remove.add(aspect)
        if len(remove) == 0:
            fatal("can't continue building tier info; needed (%d):\n %s" \
                    % (len(need), '\n    '.join(need)))
        need.difference_update(remove)
buildTier()

def groupByTier(args):
    aspectsByTier = {}
    for aspect in args:
        aspect = aspect.title()
        if aspect not in tier:
            fatal('unrecognized aspect: "%s"' % aspect)
        t = tier[aspect]
        if t not in aspectsByTier:
            aspectsByTier[t] = [aspect]
        else:
            aspectsByTier[t].append(aspect)
    return aspectsByTier

def showTier(args):
    if len(args) == 0:
        aspectsByTier = groupByTier(allAspects)
        for t in sorted(aspectsByTier.keys()):
            print "tier %d" % t
            for aspect in sorted(aspectsByTier[t]):
                print "    " + aspect
            print
        return

    unrecognized = []
    for aspect in args:
        aspect = aspect.title()
        if aspect not in tier:
            unrecognized.append(aspect)
        else:
            print "%s: tier %d" % (aspect, tier[aspect])
    if len(unrecognized) > 0:
        print "\nunrecognized:"
        for aspect in unrecognized:
            print '    "%s"' % aspect

# adj[A] = [B, C, ...]
# aspect A can be placed adjacent to B, C, ...
adj = {}
for aspect in allAspects:
    adj[aspect] = set()
for c, (a, b) in create.iteritems():
    adj[a].add(c)
    adj[b].add(c)
    adj[c].add(a)
    adj[c].add(b)

def chain(src, dst, length):
    if length < 2:
        return None

    elif length == 2:
        if dst in adj[src]:
            return [[src, dst]]
        return None

    solns = []
    for a in adj[src]:
        subSolns = chain(a, dst, length-1)
        if subSolns is not None:
            for soln in subSolns:
                solns.append([src] + soln)
    if len(solns) == 0:
        return None
    return solns

# score(aspects) is used to sort solutions from chain()
def score(args):
    return sum([tier[a] * tier[a] for a in args])

def findPath(args):
    if len(args) != 3:
        fatal("usage: %s path <src> <dst> <length>" % path.basename(sys.argv[0]))

    src = args[0].title()
    dst = args[1].title()
    length = int(args[2])
    if src not in allAspects:
        fatal("unrecognized aspect: %s" % src)
    elif dst not in allAspects:
        fatal("unrecognized aspect: %s" % dst)
    elif length < 1:
        fatal("length must be at least 1 (got %d)" % length)

    solns = chain(src, dst, length)
    if solns is None:
        fatal("no solutions")

    for soln in sorted(solns, key=score):
        print ' '.join(soln)

cmdDispatch = None

def showHelp(args):
    execName = path.basename(sys.argv[0])

    if len(args) == 0 or len(args) > 1:
        print "usage: %s <command> [args]*" % execName
        print
        for (_, fmt, desc) in cmdDispatch.values():
            print fmt % execName
            print "    " + desc

    else:
        topic = args[0]
        if topic not in cmdDispatch:
            fatal("unrecognized command: " + topic)
        _, fmt, desc = cmdDispatch[topic]
        print fmt % execName
        print "    " + desc

cmdDispatch = {
    "help": (showHelp, "%s help [cmd]",
            "show general help, or help for a specific command"),
    "list": (listAspects, "%s list [aspect]*",
            "show formulas for named aspects, or all if none given"),
    "make": (makeAspect, "%s make [aspect]*",
            "show formulas for named aspects, or build order to make all aspects"),
    "path": (findPath, "%s path <src> <dst> <length>",
            "show solutions to connect <src> to <dst> using <length> total tiles"),
    "tier": (showTier, "%s tier [aspect]*",
            "show the tier of named aspects, or of all aspects if none given")
}

if __name__ == "__main__":
    if len(sys.argv) == 1:
        showHelp([])
        sys.exit(0)
    command = sys.argv[1]
    if command not in cmdDispatch:
        showHelp([command])
    f, fmt, desc = cmdDispatch[command]
    f(sys.argv[2:])
